<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Synthwave Mixer: Outrun Edition v6</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body { margin: 0; overflow: hidden; background: #000; font-family: 'Press Start 2P', cursive; touch-action: none; user-select: none; -webkit-user-select: none; }
        
        /* Canvas fixed to back */
        canvas { position: fixed; top: 0; left: 0; z-index: 0; }

        /* UI Overlay Container */
        #ui-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            /* Removed flex layout constraints to allow absolute positioning of children */
            z-index: 20;
        }

        /* Left HUD Panel */
        .hud-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 250px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #00f6ff;
            padding: 15px;
            pointer-events: auto;
            border-radius: 5px;
            box-shadow: 0 0 10px #00f6ff;
            transform-origin: top left;
        }

        /* Right Top Speedometer (Moved Here) */
        #speed-hud {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
            pointer-events: none;
        }

        h1 { font-size: 24px; margin: 0 0 10px 0; background: linear-gradient(to right, #ff00de, #00f6ff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .controls-hint { font-size: 10px; color: #ccc; line-height: 1.5; }
        
        button {
            background: #ff00de; color: white; border: none; padding: 8px 12px;
            font-family: 'Press Start 2P'; font-size: 10px; cursor: pointer;
            margin-top: 5px; width: 100%; text-transform: uppercase;
            transition: 0.2s;
        }
        button:hover { background: #fff; color: #ff00de; box-shadow: 0 0 10px #fff; }
        button:active { transform: scale(0.95); }

        input[type=range] { width: 100%; margin: 5px 0; accent-color: #00f6ff; cursor: pointer; }
        label { font-size: 10px; color: #00f6ff; display: block; margin-top: 5px; }

        #speedometer { font-size: 32px; color: #ffe600; text-shadow: 2px 2px 0 #b20000; margin-bottom: 5px; }
        #turbo-text { color: #00f6ff; font-size: 12px; text-shadow: 0 0 5px #00f6ff; }
        
        /* Touch Controls */
        #touch-controls {
            position: absolute; bottom: 20px; left: 0; width: 100%; height: 120px;
            display: flex; justify-content: space-between; padding: 0 30px; box-sizing: border-box;
            pointer-events: none; z-index: 30;
        }
        .control-group { pointer-events: auto; display: flex; gap: 15px; align-items: flex-end; }
        .btn-touch {
            width: 70px; height: 70px; background: rgba(0, 0, 0, 0.3);
            border: 3px solid #00f6ff; border-radius: 50%; color: #00f6ff;
            font-size: 30px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; backdrop-filter: blur(2px); box-shadow: 0 0 10px rgba(0, 246, 255, 0.3);
            touch-action: manipulation;
        }
        .btn-touch:active, .btn-touch.active { background: rgba(0, 246, 255, 0.4); color: white; transform: scale(0.95); box-shadow: 0 0 20px #00f6ff; }
        .d-pad-right .btn-touch { border-color: #ff00de; color: #ff00de; box-shadow: 0 0 10px rgba(255, 0, 222, 0.3); }
        .d-pad-right .btn-touch:active, .d-pad-right .btn-touch.active { background: rgba(255, 0, 222, 0.4); color: white; box-shadow: 0 0 20px #ff00de; }

        @media (max-height: 500px) { .hud-panel { transform: scale(0.7); } }

        /* Start Screen Overlay */
        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); 
            z-index: 9999; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: #fff; text-align: center;
            pointer-events: auto;
        }
        #start-btn {
            font-size: 20px; padding: 20px 40px; background: transparent; border: 4px solid #00f6ff;
            color: #00f6ff; text-shadow: 0 0 10px #00f6ff; box-shadow: 0 0 20px #00f6ff;
            cursor: pointer; animation: pulse 1s infinite alternate; pointer-events: auto;
        }
        @keyframes pulse { from { box-shadow: 0 0 10px #00f6ff; } to { box-shadow: 0 0 30px #00f6ff, 0 0 10px #fff; } }

        .scanlines { position: fixed; left: 0; top: 0; width: 100%; height: 100%; background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2)); background-size: 100% 4px; pointer-events: none; z-index: 10; display: none; }
        .vignette { position: fixed; left: 0; top: 0; width: 100%; height: 100%; background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.6) 100%); pointer-events: none; z-index: 11; display: none; }
    </style>
</head>
<body>

<div id="start-screen">
    <h1 style="font-size: 40px; margin-bottom: 40px;">OUTRUN MIXER</h1>
    <button id="start-btn">點擊開始 / INSERT COIN</button>
    <p style="margin-top: 20px; font-size: 12px; color: #aaa;">開啟音效以獲得最佳體驗</p>
</div>

<div class="scanlines" id="css-scanlines"></div>
<div class="vignette" id="css-vignette"></div>

<div id="ui-container">
    <div class="hud-panel">
        <h1>霓虹預拌車</h1>
        <div class="controls-hint">
            [鍵盤] WASD / ⬅➡<br>
            [觸控] 螢幕下方虛擬按鍵<br>
        </div>
        <hr style="border-color: #00f6ff; opacity: 0.5;">
        <label>視覺主題</label> <button id="btn-theme">切換主題：邁阿密</button>
        <label>攝影機模式</label> <button id="btn-camera">模式：追車 (居中)</button>
        <label>CRT / 故障特效</label> <button id="btn-glitch">特效：關閉</button>
        <label>音樂 / 音效</label> <button id="btn-audio">靜音</button>
        <label>炫光強度 (Bloom)</label> <input type="range" id="slider-bloom" min="0" max="3" step="0.1" value="1.0">
        <label>環境亮度/對比</label> <input type="range" id="slider-brightness" min="0.5" max="2" step="0.1" value="1.1">
    </div>

    <div id="speed-hud">
        <div id="speedometer">60 KM/H</div>
        <div id="turbo-text">TURBO SYSTEM READY</div>
    </div>
</div>

<div id="touch-controls">
    <div class="control-group d-pad-left">
        <div class="btn-touch" data-key="ArrowLeft">⬅</div>
        <div class="btn-touch" data-key="ArrowRight">➡</div>
    </div>
    <div class="control-group d-pad-right">
        <div class="btn-touch" data-key="ArrowDown">⬇</div>
        <div class="btn-touch" data-key="ArrowUp">⬆</div>
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';

    // --- Audio Engine ---
    const AudioEngine = {
        ctx: null,
        isPlaying: false,
        nextNoteTime: 0,
        tempo: 145,
        noteIndex: 0,
        bassSequence: [36, 36, 36, 36, 39, 39, 41, 41],
        timerID: null,
        lookahead: 25.0,
        scheduleAheadTime: 0.1,

        init: function() {
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
        },

        playTone: function(freq, time, duration, type = 'sawtooth', vol = 0.1) {
            if (!this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start(time);
            gain.gain.setValueAtTime(vol, time);
            gain.gain.exponentialRampToValueAtTime(0.001, time + duration);
            osc.stop(time + duration);
        },

        playDrum: function(time, type) {
            if (!this.ctx) return;
            const gain = this.ctx.createGain();
            gain.connect(this.ctx.destination);
            
            if (type === 'kick') {
                const osc = this.ctx.createOscillator();
                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
                gain.gain.setValueAtTime(0.8, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.5);
                osc.connect(gain);
                osc.start(time);
                osc.stop(time + 0.5);
            } else if (type === 'snare') {
                const bufferSize = this.ctx.sampleRate * 0.5;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 1000;
                noise.connect(filter);
                filter.connect(gain);
                gain.gain.setValueAtTime(0.3, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.2);
                noise.start(time);
            }
        },

        scheduler: function() {
            while (this.nextNoteTime < this.ctx.currentTime + this.scheduleAheadTime) {
                this.scheduleNote(this.noteIndex, this.nextNoteTime);
                this.nextNote();
            }
            this.timerID = setTimeout(this.scheduler.bind(this), this.lookahead);
        },

        nextNote: function() {
            const secondsPerBeat = 60.0 / this.tempo;
            this.nextNoteTime += 0.25 * secondsPerBeat;
            this.noteIndex++;
            if (this.noteIndex === 16) { this.noteIndex = 0; }
        },

        scheduleNote: function(beatNumber, time) {
            if (beatNumber % 4 === 0) this.playDrum(time, 'kick');
            if (beatNumber === 4 || beatNumber === 12) this.playDrum(time, 'snare');
            if (beatNumber % 2 === 0) {
                const midi = this.bassSequence[Math.floor(beatNumber/2) % 8];
                const freq = 440 * Math.pow(2, (midi - 69) / 12);
                this.playTone(freq, time, 0.2, 'sawtooth', 0.15);
                this.playTone(freq/2, time, 0.2, 'sine', 0.3);
            }
        },

        start: function() {
            if (this.ctx.state === 'suspended') this.ctx.resume();
            this.isPlaying = true;
            this.noteIndex = 0;
            this.nextNoteTime = this.ctx.currentTime + 0.1;
            this.scheduler();
        },

        stop: function() {
            this.isPlaying = false;
            clearTimeout(this.timerID);
        },

        playTurboSFX: function() {
            if (!this.ctx) return;
            const t = this.ctx.currentTime;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, t);
            osc.frequency.linearRampToValueAtTime(600, t + 1.5);
            gain.gain.setValueAtTime(0.1, t);
            gain.gain.linearRampToValueAtTime(0.0, t + 1.5);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start(t);
            osc.stop(t + 1.5);

            const bufferSize = this.ctx.sampleRate * 1.5;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(400, t);
            filter.frequency.linearRampToValueAtTime(5000, t + 1.0);
            const nGain = this.ctx.createGain();
            nGain.gain.setValueAtTime(0.2, t);
            nGain.gain.exponentialRampToValueAtTime(0.001, t + 1.5);
            noise.connect(filter);
            filter.connect(nGain);
            nGain.connect(this.ctx.destination);
            noise.start(t);
        }
    };

    // --- Configuration & State ---
    const CONFIG = {
        speed: 60, turnSpeed: 0.8, tiltFactor: 0.3, fovBase: 60, fovTurbo: 90, horizonZ: -250, cameraZPass: 20
    };

    const THEMES = [
        { name: '邁阿密', sky: 0x2b0033, grid: 0xff00de, sunTop: 0xffe600, sunBot: 0xff0055, fog: 0x2b0033 },
        { name: '網路', sky: 0x001133, grid: 0x00f6ff, sunTop: 0xffffff, sunBot: 0x00f6ff, fog: 0x001133 },
        { name: '黃金', sky: 0x111111, grid: 0xffaa00, sunTop: 0xffd700, sunBot: 0x996600, fog: 0x111111 }
    ];

    let currentThemeIdx = 0;
    let gameState = { speed: 0.5, realSpeed: 60, steering: 0, turbo: false, turboTriggered: false };

    // --- Scene Setup ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(THEMES[0].fog, 0.015);
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 3, 8);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.ReinhardToneMapping;
    document.body.appendChild(renderer.domElement);

    // --- Assets ---
    // Road
    const gridVertexShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`;
    const gridFragmentShader = `uniform float time; uniform vec3 color; varying vec2 vUv; void main() { vec2 grid = abs(fract(vUv * vec2(1.0, 20.0) + vec2(0.0, time)) - 0.5) / fwidth(vUv * vec2(1.0, 20.0)); float line = min(grid.x, grid.y); float fade = 1.0 - vUv.y; gl_FragColor = vec4(color * (1.0 - min(line, 1.0)), fade * max(0.0, (1.0 - min(line, 1.0)))); }`;
    const gridUniforms = { time: { value: 0 }, color: { value: new THREE.Color(THEMES[0].grid) } };
    const road = new THREE.Mesh(new THREE.PlaneGeometry(40, 300).rotateX(-Math.PI / 2).translate(0,0,-100), new THREE.ShaderMaterial({ uniforms: gridUniforms, vertexShader: gridVertexShader, fragmentShader: gridFragmentShader, transparent: true, side: THREE.DoubleSide }));
    scene.add(road);

    // Sun
    const sunMat = new THREE.ShaderMaterial({ uniforms: { colorTop: { value: new THREE.Color(THEMES[0].sunTop) }, colorBot: { value: new THREE.Color(THEMES[0].sunBot) } }, vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`, fragmentShader: `uniform vec3 colorTop; uniform vec3 colorBot; varying vec2 vUv; void main() { float y = vUv.y; float stripe = step(0.5, sin(y * 40.0)); if (y < 0.5 && stripe < 0.1) discard; gl_FragColor = vec4(mix(colorBot, colorTop, y), 1.0); }`, transparent: true });
    const sun = new THREE.Mesh(new THREE.CircleGeometry(25, 32), sunMat);
    sun.position.set(0, 15, -200); scene.add(sun);

    // Buildings
    const buildings = [];
    const buildingGeo = new THREE.BoxGeometry(1, 1, 1); buildingGeo.translate(0, 0.5, 0); 
    function resetBuilding(b) { b.position.z = CONFIG.horizonZ + Math.random() * 50; const side = Math.random() > 0.5 ? 1 : -1; b.position.x = side * (20 + Math.random() * 15); b.scale.set(5 + Math.random() * 10, 10 + Math.random() * 40, 5 + Math.random() * 10); if (b.material) b.material.color.setHex(THEMES[currentThemeIdx].grid); }
    for (let i = 0; i < 30; i++) { const mat = new THREE.MeshBasicMaterial({ color: THEMES[0].grid, wireframe: true, transparent: true, opacity: 0.6, fog: true }); const b = new THREE.Mesh(buildingGeo, mat); resetBuilding(b); b.position.z = CONFIG.horizonZ + (i / 30) * (CONFIG.cameraZPass - CONFIG.horizonZ); scene.add(b); buildings.push(b); }

    // Truck
    const truckGroup = new THREE.Group();
    const chassisMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.2 });
    const cabinMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1, metalness: 0.5 });
    const drumMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.3, metalness: 0.4, flatShading: true });
    const chassis = new THREE.Mesh(new THREE.BoxGeometry(2, 0.8, 6), chassisMat); chassis.position.y = 0.8; truckGroup.add(chassis);
    const cabin = new THREE.Mesh(new THREE.BoxGeometry(2, 1.8, 1.5), cabinMat); cabin.position.set(0, 1.8, -1.8); truckGroup.add(cabin);
    const windshield = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.8, 0.1), new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0, metalness: 0.9 })); windshield.position.set(0, 2.0, -2.56); truckGroup.add(windshield);
    const drumGeo = new THREE.CylinderGeometry(1.3, 0.5, 3.5, 7); const drum = new THREE.Mesh(drumGeo, drumMat); drum.rotation.x = Math.PI / 2; 
    const drumPivot = new THREE.Group(); drumPivot.position.set(0, 2.0, 1.0); drumPivot.rotation.x = -0.2; drumPivot.add(drum); truckGroup.add(drumPivot);
    const wheelGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 12).rotateZ(Math.PI/2);
    truckGroup.add(new THREE.Mesh(wheelGeo, chassisMat).position.set(1.1, 0.6, 1.5)); truckGroup.add(new THREE.Mesh(wheelGeo, chassisMat).position.set(-1.1, 0.6, 1.5)); truckGroup.add(new THREE.Mesh(wheelGeo, chassisMat).position.set(1.1, 0.6, -1.5)); truckGroup.add(new THREE.Mesh(wheelGeo, chassisMat).position.set(-1.1, 0.6, -1.5));
    const hlMat = new THREE.MeshBasicMaterial({color:0xffff00}); truckGroup.add(new THREE.Mesh(new THREE.BoxGeometry(0.4,0.2,0.1), hlMat).position.set(0.6,1.2,-2.55)); truckGroup.add(new THREE.Mesh(new THREE.BoxGeometry(0.4,0.2,0.1), hlMat).position.set(-0.6,1.2,-2.55));
    const tlMat = new THREE.MeshBasicMaterial({color:0xff0000}); truckGroup.add(new THREE.Mesh(new THREE.BoxGeometry(0.3,0.1,0.1), tlMat).position.set(0.6,1.0,3.0)); truckGroup.add(new THREE.Mesh(new THREE.BoxGeometry(0.3,0.1,0.1), tlMat).position.set(-0.6,1.0,3.0));
    
    truckGroup.scale.set(0.5, 0.5, 0.5); // Scale down truck by 50%
    scene.add(truckGroup);

    // Lights
    scene.add(new THREE.AmbientLight(0x404040, 2));
    const dirLight = new THREE.DirectionalLight(0xffffff, 2); dirLight.position.set(0, 10, -50); scene.add(dirLight);
    const pointLight = new THREE.PointLight(THEMES[0].grid, 1, 20); pointLight.position.set(0, 2, 0); scene.add(pointLight);

    // --- Post Processing ---
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.0, 0.4, 0.85);
    bloomPass.threshold = 0.1; bloomPass.strength = 1.0; bloomPass.radius = 0.5; composer.addPass(bloomPass);
    const filmPass = new FilmPass(0.35, 0.025, 648, false); filmPass.enabled = false; composer.addPass(filmPass);
    const crtShader = { uniforms: { "tDiffuse": { value: null }, "brightness": { value: 1.1 }, "contrast": { value: 1.0 }, "time": { value: 0.0 }, "glitchIntensity": { value: 0.0 } }, vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`, fragmentShader: `uniform sampler2D tDiffuse; uniform float brightness; uniform float contrast; uniform float time; uniform float glitchIntensity; varying vec2 vUv; float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); } void main() { vec2 uv = vUv; if (glitchIntensity > 0.0) { float g = rand(vec2(floor(uv.y * 20.0), time)); if (g < glitchIntensity) { uv.x += (rand(vec2(time)) - 0.5) * 0.05; } } vec4 color = texture2D(tDiffuse, uv); color.rgb = (color.rgb - 0.5) * contrast + 0.5; color.rgb *= brightness; gl_FragColor = color; }` };
    const crtPass = new ShaderPass(crtShader); composer.addPass(crtPass);

    // --- Inputs ---
    const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, w: false, s: false, a: false, d: false, " ": false };
    window.addEventListener('keydown', (e) => keys[e.key] = true); window.addEventListener('keyup', (e) => keys[e.key] = false);
    
    const touchBtns = document.querySelectorAll('.btn-touch');
    touchBtns.forEach(btn => {
        const key = btn.getAttribute('data-key');
        const press = (e) => { if(e.cancelable) e.preventDefault(); keys[key] = true; btn.classList.add('active'); };
        const release = (e) => { if(e.cancelable) e.preventDefault(); keys[key] = false; btn.classList.remove('active'); };
        btn.addEventListener('mousedown', press); btn.addEventListener('mouseup', release); btn.addEventListener('mouseleave', release);
        btn.addEventListener('touchstart', press); btn.addEventListener('touchend', release);
    });

    // --- UI Logic ---
    let cameraMode = 'chase'; let glitchEnabled = false;
    
    const startGame = () => {
        const startScreen = document.getElementById('start-screen');
        if (startScreen) startScreen.style.display = 'none';
        try { AudioEngine.init(); AudioEngine.start(); document.getElementById('btn-audio').innerText = '音樂：開啟'; } catch (e) { console.log("Audio error", e); }
    };
    const startBtn = document.getElementById('start-btn');
    startBtn.addEventListener('click', startGame);
    startBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startGame(); });

    document.getElementById('btn-theme').addEventListener('click', () => { currentThemeIdx = (currentThemeIdx + 1) % THEMES.length; const t = THEMES[currentThemeIdx]; document.getElementById('btn-theme').innerText = `切換主題：${t.name}`; scene.fog.color.setHex(t.fog); gridUniforms.color.value.setHex(t.grid); sunMat.uniforms.colorTop.value.setHex(t.sunTop); sunMat.uniforms.colorBot.value.setHex(t.sunBot); pointLight.color.setHex(t.grid); buildings.forEach(b => b.material.color.setHex(t.grid)); });
    document.getElementById('btn-camera').addEventListener('click', () => { cameraMode = cameraMode === 'chase' ? 'free' : 'chase'; document.getElementById('btn-camera').innerText = `模式：${cameraMode === 'chase' ? '追車 (居中)' : '自由 (跟隨)'}`; });
    document.getElementById('btn-glitch').addEventListener('click', () => { glitchEnabled = !glitchEnabled; document.getElementById('btn-glitch').innerText = `特效：${glitchEnabled ? '開啟' : '關閉'}`; filmPass.enabled = glitchEnabled; document.getElementById('css-scanlines').style.display = glitchEnabled ? 'block' : 'none'; document.getElementById('css-vignette').style.display = glitchEnabled ? 'block' : 'none'; });
    document.getElementById('btn-audio').addEventListener('click', () => { 
        if (!AudioEngine.ctx) { try { AudioEngine.init(); AudioEngine.start(); document.getElementById('btn-audio').innerText = '音樂：開啟'; } catch(e){} } 
        else if (AudioEngine.isPlaying) { AudioEngine.stop(); document.getElementById('btn-audio').innerText = '音樂：靜音'; }
        else { AudioEngine.start(); document.getElementById('btn-audio').innerText = '音樂：開啟'; }
    });
    document.getElementById('slider-bloom').addEventListener('input', (e) => bloomPass.strength = parseFloat(e.target.value));
    document.getElementById('slider-brightness').addEventListener('input', (e) => crtPass.uniforms.brightness.value = parseFloat(e.target.value));

    // --- Game Loop ---
    const clock = new THREE.Clock();
    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta(); const time = clock.getElapsedTime();
        
        if (keys.ArrowUp || keys.w || keys[" "]) { 
            gameState.speed = Math.min(gameState.speed + 0.02, 1.5); 
            gameState.turbo = true;
            if (!gameState.turboTriggered && gameState.speed > 1.0) { AudioEngine.playTurboSFX(); gameState.turboTriggered = true; }
        } else { 
            gameState.speed = Math.max(gameState.speed - 0.01, 0.5); 
            gameState.turbo = false;
            gameState.turboTriggered = false;
        }
        
        let steerInput = 0; if (keys.ArrowLeft || keys.a) steerInput = -1; if (keys.ArrowRight || keys.d) steerInput = 1;
        gameState.steering += (steerInput - gameState.steering) * 0.1;
        gameState.realSpeed = Math.floor(CONFIG.speed + (gameState.speed - 0.5) * 100);
        document.getElementById('speedometer').innerText = `${gameState.realSpeed} KM/H`; document.getElementById('speedometer').style.color = gameState.turbo ? '#00f6ff' : '#ffe600';

        drum.rotation.y += (gameState.realSpeed / 60) * 5 * delta; 
        truckGroup.position.x += gameState.steering * CONFIG.turnSpeed * (gameState.realSpeed / 60) * delta * 10;
        truckGroup.position.x = Math.max(-18, Math.min(18, truckGroup.position.x));
        truckGroup.rotation.z = gameState.steering * -CONFIG.tiltFactor; truckGroup.rotation.y = gameState.steering * 0.1; truckGroup.position.y = Math.sin(time * 20) * 0.02;
        
        gridUniforms.time.value -= gameState.speed * 10 * delta;
        const moveSpeed = gameState.speed * 70 * delta;
        buildings.forEach(b => { b.position.z += moveSpeed; if (b.position.z > CONFIG.cameraZPass) { resetBuilding(b); } });

        const targetFov = gameState.turbo ? CONFIG.fovTurbo : CONFIG.fovBase; camera.fov += (targetFov - camera.fov) * 0.05; camera.updateProjectionMatrix();
        if (cameraMode === 'chase') { camera.position.x += (0 - camera.position.x) * 0.1; camera.position.z = truckGroup.position.z + 8; camera.lookAt(0, 2, truckGroup.position.z - 10); } else { camera.position.x += ((truckGroup.position.x * 0.5) - camera.position.x) * 0.1; camera.position.z = truckGroup.position.z + 9; camera.lookAt(truckGroup.position.x, 2, truckGroup.position.z - 10); }

        crtPass.uniforms.time.value = time; crtPass.uniforms.glitchIntensity.value = (glitchEnabled && Math.random() > 0.98) ? 0.2 : 0.0;
        composer.render();
    }
    animate();
    window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); });
</script>
</body>
</html>
