<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Synthwave Mixer: Outrun Edition v4 (Front Fixed)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body { margin: 0; overflow: hidden; background: #000; font-family: 'Press Start 2P', cursive; }
        
        /* UI Overlay */
        #ui-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            color: #fff;
            text-shadow: 2px 2px 0 #ff00de;
        }

        /* HUD Styling */
        .hud-panel {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #00f6ff;
            padding: 15px;
            pointer-events: auto;
            border-radius: 5px;
            box-shadow: 0 0 10px #00f6ff;
        }

        h1 { font-size: 24px; margin: 0 0 10px 0; background: linear-gradient(to right, #ff00de, #00f6ff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        
        .controls-hint { font-size: 10px; color: #ccc; line-height: 1.5; }
        
        /* Buttons & Sliders */
        button {
            background: #ff00de; color: white; border: none; padding: 8px 12px;
            font-family: 'Press Start 2P'; font-size: 10px; cursor: pointer;
            margin-top: 5px; width: 100%; text-transform: uppercase;
            transition: 0.2s;
        }
        button:hover { background: #fff; color: #ff00de; box-shadow: 0 0 10px #fff; }
        button:active { transform: scale(0.95); }

        input[type=range] { width: 100%; margin: 5px 0; accent-color: #00f6ff; cursor: pointer; }
        label { font-size: 10px; color: #00f6ff; display: block; margin-top: 5px; }

        #speedometer { font-size: 32px; text-align: right; color: #ffe600; text-shadow: 2px 2px 0 #b20000; }
        
        /* CRT Overlay Effect */
        .scanlines {
            position: fixed; left: 0; top: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
            display: none;
        }
        .vignette {
            position: fixed; left: 0; top: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.6) 100%);
            pointer-events: none;
            z-index: 11;
            display: none;
        }

        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 20px; }
    </style>
</head>
<body>

<div id="loading">載入 80s 模組中...</div>
<div class="scanlines" id="css-scanlines"></div>
<div class="vignette" id="css-vignette"></div>

<div id="ui-container">
    <div class="hud-panel" style="width: 250px;">
        <h1>霓虹預拌車</h1>
        <div class="controls-hint">
            [WASD / ⬅➡] 轉向<br>
            [SPACE / ⬆] 加速 (Turbo)<br>
        </div>
        <hr style="border-color: #00f6ff; opacity: 0.5;">
        
        <label>視覺主題</label>
        <button id="btn-theme">切換主題：邁阿密</button>

        <label>攝影機模式</label>
        <button id="btn-camera">模式：追車 (居中)</button>
        
        <label>CRT / 故障特效</label>
        <button id="btn-glitch">特效：關閉</button>

        <label>炫光強度 (Bloom)</label>
        <input type="range" id="slider-bloom" min="0" max="3" step="0.1" value="1.0">

        <label>環境亮度/對比</label>
        <input type="range" id="slider-brightness" min="0.5" max="2" step="0.1" value="1.1">
    </div>

    <div style="align-self: flex-end; text-align: right;">
        <div id="speedometer">60 KM/H</div>
        <div style="color: #00f6ff; font-size: 12px;">TURBO SYSTEM READY</div>
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';

    // --- Configuration & State ---
    const CONFIG = {
        speed: 60,
        turnSpeed: 0.8,
        tiltFactor: 0.3, // Truck leans into turn
        fovBase: 60,
        fovTurbo: 90,
        horizonZ: -250,
        cameraZPass: 20
    };

    const THEMES = [
        { name: '邁阿密', sky: 0x2b0033, grid: 0xff00de, sunTop: 0xffe600, sunBot: 0xff0055, fog: 0x2b0033 },
        { name: '網路', sky: 0x001133, grid: 0x00f6ff, sunTop: 0xffffff, sunBot: 0x00f6ff, fog: 0x001133 },
        { name: '黃金', sky: 0x111111, grid: 0xffaa00, sunTop: 0xffd700, sunBot: 0x996600, fog: 0x111111 }
    ];

    let currentThemeIdx = 0;
    let gameState = {
        speed: 0.5, 
        realSpeed: 60,
        steering: 0,
        turbo: false
    };

    // --- Scene Setup ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(THEMES[0].fog, 0.015);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    // Camera positioned behind (Positive Z) looking forward (Negative Z)
    camera.position.set(0, 3, 8);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.ReinhardToneMapping;
    document.body.appendChild(renderer.domElement);

    // --- Assets Generation (Procedural) ---
    // 1. The Grid Road
    const gridVertexShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`;
    const gridFragmentShader = `
        uniform float time; uniform vec3 color; varying vec2 vUv;
        void main() {
            // Grid moves towards camera (+Z), simulating forward motion into -Z
            vec2 grid = abs(fract(vUv * vec2(1.0, 20.0) + vec2(0.0, time)) - 0.5) / fwidth(vUv * vec2(1.0, 20.0));
            float line = min(grid.x, grid.y);
            float fade = 1.0 - vUv.y; 
            gl_FragColor = vec4(color * (1.0 - min(line, 1.0)), fade * max(0.0, (1.0 - min(line, 1.0))));
        }
    `;
    const gridUniforms = { time: { value: 0 }, color: { value: new THREE.Color(THEMES[0].grid) } };
    const road = new THREE.Mesh(new THREE.PlaneGeometry(40, 300).rotateX(-Math.PI / 2).translate(0,0,-100), new THREE.ShaderMaterial({ uniforms: gridUniforms, vertexShader: gridVertexShader, fragmentShader: gridFragmentShader, transparent: true, side: THREE.DoubleSide }));
    scene.add(road);

    // 2. The Sun (At far negative Z)
    const sunMat = new THREE.ShaderMaterial({
        uniforms: { colorTop: { value: new THREE.Color(THEMES[0].sunTop) }, colorBot: { value: new THREE.Color(THEMES[0].sunBot) } },
        vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
        fragmentShader: `uniform vec3 colorTop; uniform vec3 colorBot; varying vec2 vUv; void main() { float y = vUv.y; float stripe = step(0.5, sin(y * 40.0)); if (y < 0.5 && stripe < 0.1) discard; gl_FragColor = vec4(mix(colorBot, colorTop, y), 1.0); }`,
        transparent: true
    });
    const sun = new THREE.Mesh(new THREE.CircleGeometry(25, 32), sunMat);
    sun.position.set(0, 15, -200); 
    scene.add(sun);

    // 3. Unfinished Buildings (Recycling)
    const buildings = [];
    const buildingGeo = new THREE.BoxGeometry(1, 1, 1);
    buildingGeo.translate(0, 0.5, 0); 
    
    function resetBuilding(b) {
        b.position.z = CONFIG.horizonZ + Math.random() * 50;
        const side = Math.random() > 0.5 ? 1 : -1;
        b.position.x = side * (20 + Math.random() * 15);
        b.scale.set(5 + Math.random() * 10, 10 + Math.random() * 40, 5 + Math.random() * 10);
        if (b.material) b.material.color.setHex(THEMES[currentThemeIdx].grid);
    }

    for (let i = 0; i < 30; i++) {
        const mat = new THREE.MeshBasicMaterial({ color: THEMES[0].grid, wireframe: true, transparent: true, opacity: 0.6, fog: true });
        const b = new THREE.Mesh(buildingGeo, mat);
        resetBuilding(b);
        b.position.z = CONFIG.horizonZ + (i / 30) * (CONFIG.cameraZPass - CONFIG.horizonZ);
        scene.add(b);
        buildings.push(b);
    }

    // 4. The Concrete Mixer Truck (FIXED: Facing -Z / Sun)
    const truckGroup = new THREE.Group();
    const chassisMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.2 });
    const cabinMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1, metalness: 0.5 });
    const drumMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.3, metalness: 0.4, flatShading: true });

    // Chassis
    const chassis = new THREE.Mesh(new THREE.BoxGeometry(2, 0.8, 6), chassisMat); 
    chassis.position.y = 0.8; 
    truckGroup.add(chassis);

    // Cabin (Moved to -Z, Front)
    const cabin = new THREE.Mesh(new THREE.BoxGeometry(2, 1.8, 1.5), cabinMat); 
    cabin.position.set(0, 1.8, -1.8); 
    truckGroup.add(cabin);
    
    // Windshield (Moved to -Z, Front)
    const windshield = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.8, 0.1), new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0, metalness: 0.9 })); 
    windshield.position.set(0, 2.0, -2.56); 
    truckGroup.add(windshield);

    // Mixer Drum (Reoriented)
    // RadiusTop=1.3 (Wide), RadiusBot=0.5 (Narrow). 
    // Rotated X 90deg: Top (+Y) goes to Back (+Z), Bot (-Y) goes to Front (-Z).
    const drumGeo = new THREE.CylinderGeometry(1.3, 0.5, 3.5, 7); 
    const drum = new THREE.Mesh(drumGeo, drumMat);
    drum.rotation.x = Math.PI / 2; 
    
    const drumPivot = new THREE.Group();
    drumPivot.position.set(0, 2.0, 1.0); // Pivot shifted to back half
    drumPivot.rotation.x = -0.2; // Tilt: Front down, Back up (Visual tilt)
    drumPivot.add(drum);
    truckGroup.add(drumPivot);

    // Wheels
    const wheelGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 12).rotateZ(Math.PI/2);
    truckGroup.add(new THREE.Mesh(wheelGeo, chassisMat).position.set(1.1, 0.6, 1.5));
    truckGroup.add(new THREE.Mesh(wheelGeo, chassisMat).position.set(-1.1, 0.6, 1.5));
    truckGroup.add(new THREE.Mesh(wheelGeo, chassisMat).position.set(1.1, 0.6, -1.5));
    truckGroup.add(new THREE.Mesh(wheelGeo, chassisMat).position.set(-1.1, 0.6, -1.5));

    // Headlights (Front, -Z)
    const hlMat = new THREE.MeshBasicMaterial({color:0xffff00});
    truckGroup.add(new THREE.Mesh(new THREE.BoxGeometry(0.4,0.2,0.1), hlMat).position.set(0.6,1.2,-2.55));
    truckGroup.add(new THREE.Mesh(new THREE.BoxGeometry(0.4,0.2,0.1), hlMat).position.set(-0.6,1.2,-2.55));

    // Taillights (Back, +Z)
    const tlMat = new THREE.MeshBasicMaterial({color:0xff0000});
    truckGroup.add(new THREE.Mesh(new THREE.BoxGeometry(0.3,0.1,0.1), tlMat).position.set(0.6,1.0,3.0));
    truckGroup.add(new THREE.Mesh(new THREE.BoxGeometry(0.3,0.1,0.1), tlMat).position.set(-0.6,1.0,3.0));
    
    scene.add(truckGroup);

    // Lights
    scene.add(new THREE.AmbientLight(0x404040, 2));
    const dirLight = new THREE.DirectionalLight(0xffffff, 2); dirLight.position.set(0, 10, -50); scene.add(dirLight);
    const pointLight = new THREE.PointLight(THEMES[0].grid, 1, 20); pointLight.position.set(0, 2, 0); scene.add(pointLight);

    // --- Post Processing ---
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.0, 0.4, 0.85);
    bloomPass.threshold = 0.1; 
    bloomPass.strength = 1.0; 
    bloomPass.radius = 0.5; 
    composer.addPass(bloomPass);
    
    const filmPass = new FilmPass(0.35, 0.025, 648, false); filmPass.enabled = false; composer.addPass(filmPass);

    const crtShader = {
        uniforms: { "tDiffuse": { value: null }, "brightness": { value: 1.1 }, "contrast": { value: 1.0 }, "time": { value: 0.0 }, "glitchIntensity": { value: 0.0 } },
        vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
        fragmentShader: `uniform sampler2D tDiffuse; uniform float brightness; uniform float contrast; uniform float time; uniform float glitchIntensity; varying vec2 vUv; float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); } void main() { vec2 uv = vUv; if (glitchIntensity > 0.0) { float g = rand(vec2(floor(uv.y * 20.0), time)); if (g < glitchIntensity) { uv.x += (rand(vec2(time)) - 0.5) * 0.05; } } vec4 color = texture2D(tDiffuse, uv); color.rgb = (color.rgb - 0.5) * contrast + 0.5; color.rgb *= brightness; gl_FragColor = color; }`
    };
    const crtPass = new ShaderPass(crtShader); composer.addPass(crtPass);

    // --- Input & UI ---
    const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, w: false, s: false, a: false, d: false, " ": false };
    window.addEventListener('keydown', (e) => keys[e.key] = true); window.addEventListener('keyup', (e) => keys[e.key] = false);
    let cameraMode = 'chase'; let glitchEnabled = false;
    document.getElementById('loading').style.display = 'none';

    document.getElementById('btn-theme').addEventListener('click', () => {
        currentThemeIdx = (currentThemeIdx + 1) % THEMES.length; const t = THEMES[currentThemeIdx];
        document.getElementById('btn-theme').innerText = `切換主題：${t.name}`;
        scene.fog.color.setHex(t.fog); gridUniforms.color.value.setHex(t.grid); sunMat.uniforms.colorTop.value.setHex(t.sunTop); sunMat.uniforms.colorBot.value.setHex(t.sunBot); pointLight.color.setHex(t.grid);
        buildings.forEach(b => b.material.color.setHex(t.grid));
    });
    document.getElementById('btn-camera').addEventListener('click', () => { cameraMode = cameraMode === 'chase' ? 'free' : 'chase'; document.getElementById('btn-camera').innerText = `模式：${cameraMode === 'chase' ? '追車 (居中)' : '自由 (跟隨)'}`; });
    document.getElementById('btn-glitch').addEventListener('click', () => { glitchEnabled = !glitchEnabled; document.getElementById('btn-glitch').innerText = `特效：${glitchEnabled ? '開啟' : '關閉'}`; filmPass.enabled = glitchEnabled; document.getElementById('css-scanlines').style.display = glitchEnabled ? 'block' : 'none'; document.getElementById('css-vignette').style.display = glitchEnabled ? 'block' : 'none'; });
    document.getElementById('slider-bloom').addEventListener('input', (e) => bloomPass.strength = parseFloat(e.target.value));
    document.getElementById('slider-brightness').addEventListener('input', (e) => crtPass.uniforms.brightness.value = parseFloat(e.target.value));

    // --- Game Loop ---
    const clock = new THREE.Clock();
    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta(); const time = clock.getElapsedTime();
        
        if (keys.ArrowUp || keys.w || keys[" "]) { gameState.speed = Math.min(gameState.speed + 0.02, 1.5); gameState.turbo = true; } else { gameState.speed = Math.max(gameState.speed - 0.01, 0.5); gameState.turbo = false; }
        
        // Steering Logic (Left = -X, Right = +X)
        let steerInput = 0; 
        if (keys.ArrowLeft || keys.a) steerInput = -1; 
        if (keys.ArrowRight || keys.d) steerInput = 1;
        
        gameState.steering += (steerInput - gameState.steering) * 0.1;
        gameState.realSpeed = Math.floor(CONFIG.speed + (gameState.speed - 0.5) * 100);
        document.getElementById('speedometer').innerText = `${gameState.realSpeed} KM/H`; document.getElementById('speedometer').style.color = gameState.turbo ? '#00f6ff' : '#ffe600';

        // Animation
        drum.rotation.y += (gameState.realSpeed / 60) * 5 * delta; // Drum Spin
        
        // Truck Movement
        truckGroup.position.x += gameState.steering * CONFIG.turnSpeed * (gameState.realSpeed / 60) * delta * 10;
        truckGroup.position.x = Math.max(-18, Math.min(18, truckGroup.position.x));
        
        // Body Roll (Steering right 1 -> Roll Right -Z)
        truckGroup.rotation.z = gameState.steering * -CONFIG.tiltFactor; 
        truckGroup.rotation.y = gameState.steering * 0.1; 
        truckGroup.position.y = Math.sin(time * 20) * 0.02;
        
        // Environment Move
        gridUniforms.time.value -= gameState.speed * 10 * delta;

        // Buildings Move (+Z direction towards camera)
        const moveSpeed = gameState.speed * 70 * delta;
        buildings.forEach(b => {
            b.position.z += moveSpeed; 
            if (b.position.z > CONFIG.cameraZPass) {
                resetBuilding(b); 
            }
        });

        // Camera
        const targetFov = gameState.turbo ? CONFIG.fovTurbo : CONFIG.fovBase; camera.fov += (targetFov - camera.fov) * 0.05; camera.updateProjectionMatrix();
        
        // Camera Follow Logic (Looking at Truck Back)
        // Truck is at Z=0. Camera at Z=+8. Looking at Z=-10 (Front of truck/Road).
        // Need to offset lookAt to maintain "Outrun" angle
        if (cameraMode === 'chase') { 
            camera.position.x += (0 - camera.position.x) * 0.1; 
            camera.position.z = truckGroup.position.z + 8; 
            camera.lookAt(0, 2, truckGroup.position.z - 10); // Look ahead of the truck
        } else { 
            camera.position.x += ((truckGroup.position.x * 0.5) - camera.position.x) * 0.1; 
            camera.position.z = truckGroup.position.z + 9; 
            camera.lookAt(truckGroup.position.x, 2, truckGroup.position.z - 10); 
        }

        crtPass.uniforms.time.value = time; crtPass.uniforms.glitchIntensity.value = (glitchEnabled && Math.random() > 0.98) ? 0.2 : 0.0;
        composer.render();
    }
    animate();
    window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); });
</script>
</body>
</html>
